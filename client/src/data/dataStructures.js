export const dataStructures = [
  {
    id: 'array',
    name: 'Array',
    category: 'linear',
    difficulty: 'easy',
    description: 'A collection of elements stored at contiguous memory locations.',
    timeComplexity: {
      access: 'O(1)',
      search: 'O(n)',
      insertion: 'O(n)',
      deletion: 'O(n)',
    },
    spaceComplexity: 'O(n)',
    operations: ['access', 'insert', 'delete', 'search'],
  },
  {
    id: 'linked-list',
    name: 'Linked List',
    category: 'linear',
    difficulty: 'easy',
    description: 'A linear collection of data elements where each element points to the next.',
    timeComplexity: {
      access: 'O(n)',
      search: 'O(n)',
      insertion: 'O(1)',
      deletion: 'O(1)',
    },
    spaceComplexity: 'O(n)',
    operations: ['insertAtHead', 'insertAtTail', 'delete', 'search', 'reverse'],
  },
  {
    id: 'stack',
    name: 'Stack',
    category: 'linear',
    difficulty: 'easy',
    description: 'A LIFO (Last In First Out) data structure.',
    timeComplexity: {
      push: 'O(1)',
      pop: 'O(1)',
      peek: 'O(1)',
    },
    spaceComplexity: 'O(n)',
    operations: ['push', 'pop', 'peek', 'isEmpty'],
  },
  {
    id: 'queue',
    name: 'Queue',
    category: 'linear',
    difficulty: 'easy',
    description: 'A FIFO (First In First Out) data structure.',
    timeComplexity: {
      enqueue: 'O(1)',
      dequeue: 'O(1)',
      peek: 'O(1)',
    },
    spaceComplexity: 'O(n)',
    operations: ['enqueue', 'dequeue', 'peek', 'isEmpty'],
  },
  {
    id: 'binary-tree',
    name: 'Binary Tree',
    category: 'tree',
    difficulty: 'medium',
    description: 'A hierarchical structure where each node has at most two children.',
    timeComplexity: {
      search: 'O(n)',
      insertion: 'O(n)',
      deletion: 'O(n)',
    },
    spaceComplexity: 'O(n)',
    operations: ['insert', 'delete', 'inorder', 'preorder', 'postorder', 'levelorder'],
  },
  {
    id: 'bst',
    name: 'Binary Search Tree',
    category: 'tree',
    difficulty: 'medium',
    description: 'A binary tree where left child < parent < right child.',
    timeComplexity: {
      search: 'O(log n)',
      insertion: 'O(log n)',
      deletion: 'O(log n)',
    },
    spaceComplexity: 'O(n)',
    operations: ['insert', 'delete', 'search', 'min', 'max'],
  },
  {
    id: 'graph',
    name: 'Graph',
    category: 'graph',
    difficulty: 'hard',
    description: 'A collection of nodes connected by edges.',
    timeComplexity: {
      addVertex: 'O(1)',
      addEdge: 'O(1)',
      removeVertex: 'O(V + E)',
      removeEdge: 'O(E)',
    },
    spaceComplexity: 'O(V + E)',
    operations: ['addVertex', 'addEdge', 'bfs', 'dfs', 'dijkstra'],
  },
  {
    id: 'hash-table',
    name: 'Hash Table',
    category: 'hashing',
    difficulty: 'medium',
    description: 'A data structure that maps keys to values for efficient lookup.',
    timeComplexity: {
      search: 'O(1)',
      insertion: 'O(1)',
      deletion: 'O(1)',
    },
    spaceComplexity: 'O(n)',
    operations: ['insert', 'delete', 'search', 'resize'],
  },
];

export const algorithms = [
  {
    id: 'bubble-sort',
    name: 'Bubble Sort',
    category: 'sorting',
    difficulty: 'easy',
    description: 'Repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.',
    timeComplexity: {
      best: 'O(n)',
      average: 'O(n²)',
      worst: 'O(n²)',
    },
    spaceComplexity: 'O(1)',
  },
  {
    id: 'quick-sort',
    name: 'Quick Sort',
    category: 'sorting',
    difficulty: 'medium',
    description: 'Divide-and-conquer algorithm that picks a pivot and partitions the array around it.',
    timeComplexity: {
      best: 'O(n log n)',
      average: 'O(n log n)',
      worst: 'O(n²)',
    },
    spaceComplexity: 'O(log n)',
  },
  {
    id: 'merge-sort',
    name: 'Merge Sort',
    category: 'sorting',
    difficulty: 'medium',
    description: 'Divide-and-conquer algorithm that divides the array into halves, sorts them and merges them back.',
    timeComplexity: {
      best: 'O(n log n)',
      average: 'O(n log n)',
      worst: 'O(n log n)',
    },
    spaceComplexity: 'O(n)',
  },
  {
    id: 'binary-search',
    name: 'Binary Search',
    category: 'searching',
    difficulty: 'easy',
    description: 'Efficiently finds an element in a sorted array by repeatedly dividing the search interval in half.',
    timeComplexity: {
      best: 'O(1)',
      average: 'O(log n)',
      worst: 'O(log n)',
    },
    spaceComplexity: 'O(1)',
  },
  {
    id: 'bfs',
    name: 'Breadth-First Search',
    category: 'graph',
    difficulty: 'medium',
    description: 'Explores all vertices at the present depth before moving to vertices at the next depth level.',
    timeComplexity: {
      best: 'O(V + E)',
      average: 'O(V + E)',
      worst: 'O(V + E)',
    },
    spaceComplexity: 'O(V)',
  },
  {
    id: 'dfs',
    name: 'Depth-First Search',
    category: 'graph',
    difficulty: 'medium',
    description: 'Explores as far as possible along each branch before backtracking.',
    timeComplexity: {
      best: 'O(V + E)',
      average: 'O(V + E)',
      worst: 'O(V + E)',
    },
    spaceComplexity: 'O(V)',
  },
  {
    id: 'dijkstra',
    name: "Dijkstra's Algorithm",
    category: 'graph',
    difficulty: 'hard',
    description: 'Finds the shortest path between nodes in a graph with non-negative edge weights.',
    timeComplexity: {
      best: 'O((V + E) log V)',
      average: 'O((V + E) log V)',
      worst: 'O((V + E) log V)',
    },
    spaceComplexity: 'O(V)',
  },
];
